[
["assignment-second-lead-from-ecg.html", "2.7 assignment Second Lead from ECG", " 2.7 assignment Second Lead from ECG Assignment from Lesson 3 2020-02-29 Consider the file A0001.mat from the PhysioNet Challenge https://physionetchallenges.github.io/2020/. Using R: Plot the histogram of all the 12 ECG leads with the respective density curve. Using the second lead inverted, apply the expectation-maximization algorithm with 2 and 3 latent classes. Plot the densities for each of the latent classes. Which point in the ECG belongs to each latent class? Plot the ECG in which each point has a color corresponding to the class to which it belongs. Use the difference between the averages of class distribution as the convergence criterion. Generate 1000 data points at random according to a single distribution fitted to the original data. Generate 1000 data points at random according to a mixture of distributions fitted using one of the previous EM computed in line b. 2.7.1 Defining a function for expectation-maximization (EM) algorithm # function for Expectation-Maximization algorithm emf&lt;-function(xx = vv, # a vector with the data m = 2, # number of clusters method = &quot;crisp&quot;, # method used for parameters estimation in each class; options: &quot;crisp&quot; or &quot;soft&quot; itera = 10, # number of iterations eps = 0.01, # the accepted error to converge (e) params = &quot;random&quot;, # initial parameters, if &quot;random&quot; &#39;m&#39; values from &#39;xx&#39; are randomly select, or we can input a vector with &#39;m&#39; values main=&quot;ECG&quot;, # histogram title seed = 0 # value for set.seed() ){ medias=NA desvpadrao=NA if (params == &quot;random&quot;) { set.seed(seed) param.mean&lt;-sample(xx,m) param.sd&lt;-rep(sd(xx)/m,m) } else { param.mean&lt;-params param.sd&lt;-rep(sd(xx)/m,m) } for (k in 1:itera){ densities&lt;-sapply(1:m, function(i){dnorm(xx, mean=param.mean[i], sd=param.sd[i])}) relevance&lt;-t(apply(densities,1,function(l){l/sum(l)})) attrib&lt;-t(apply(relevance,1, function(l){replace(rep(0,m),which.max(l)[1],1)})) # Re-estimates the parameters of the probability distribution of each class if (method == &quot;crisp&quot;) { ## M-step (alternative 1: crisp) param.mean.new&lt;-sapply(1:m, function(j){mean(xx[attrib[,j]==1])}) param.sd.new&lt;-sapply(1:m, function(j){sqrt(sum(relevance[,j]*(xx-param.mean[j])^2)/sum(relevance[,j]))}) } else { ## M-step (alternative 2: soft) param.mean.new&lt;-sapply(1:m, function(j){sum(xx*relevance[,j])/sum(relevance[,j])}) param.sd.new&lt;-sapply(1:m, function(j){sqrt(sum(relevance[,j]*(xx-param.mean[j])^2)/sum(relevance[,j]))}) } # convergence the maximum number of iterations (k). cat(&quot;iteration&quot;, k, &quot;evolution:&quot;, dif&lt;-sum(abs(param.mean.new - param.mean)), &quot;\\n&quot;) # using the difference between the averages of class distribution as the convergence criterion. if(dif &lt; eps) break # the accepted error to converge (e) param.mean&lt;-param.mean.new param.sd&lt;-param.sd.new } ## ploting the histogram and density curve for the vector of data hist(xx, density = 20, main=main, xlab=&quot;&quot;, freq=F, ylim = c(0,0.005)) lines(density(xx), lwd=2,col=&quot;black&quot;) # plot(xx, col=apply(-densities,1,which.max), # xlab = &quot;Index&quot;, # ylab = &quot;ECG Values&quot;, main = &quot;Colored by class&quot;) #plot colours according to vector densities ## save means, std deviations and classes&#39; attributes on a list result&lt;-list(medias = param.mean, desvpadrao = param.sd, classe = as.data.frame(attrib)) } 2.7.2 reading the data and ploting the leads distribution library(R.matlab) ## R.matlab v3.6.2 (2018-09-26) successfully loaded. See ?R.matlab for help. ## ## Attaching package: &#39;R.matlab&#39; ## The following objects are masked from &#39;package:base&#39;: ## ## getOption, isOpen # after unzip the files, I took the first file fA1&lt;-readMat(&quot;2.UploadedData/A0001.mat&quot;)$val fA1&lt;-t(fA1) par(mfrow=c(3,4)) # Ploting the histogram of all the 12 ECG leads with the respective density curve. for(i in 1:12){ hist(fA1[,i], density = 10, main=paste(&quot;ECG lead&quot;,i, sep = &quot; &quot;), freq=F, ylim=c(0,max(density(fA1[,i]*(-1))[[&quot;y&quot;]])), xlab=&quot;ECG values&quot;) lines(density(fA1[,i]), lwd=2,col=&quot;black&quot;) } 2.7.3 EM algorithm for 2 latent classes par(mfrow=c(1,1)) # expectation-maximization algorithm with 2 latent classes and a maximum 50 iterations. res&lt;-emf(xx = fA1[,2]*(-1), itera = 50, m=2, method = &quot;crisp&quot;, main = &quot;second lead inverted&quot;, seed = 10) ## iteration 1 evolution: 63.64733 ## iteration 2 evolution: 46.32738 ## iteration 3 evolution: 52.78091 ## iteration 4 evolution: 23.65685 ## iteration 5 evolution: 13.68977 ## iteration 6 evolution: 10.54316 ## iteration 7 evolution: 9.96314 ## iteration 8 evolution: 7.105816 ## iteration 9 evolution: 5.806118 ## iteration 10 evolution: 4.504107 ## iteration 11 evolution: 4.9698 ## iteration 12 evolution: 5.118377 ## iteration 13 evolution: 5.773136 ## iteration 14 evolution: 6.764423 ## iteration 15 evolution: 5.433114 ## iteration 16 evolution: 7.445487 ## iteration 17 evolution: 8.256206 ## iteration 18 evolution: 7.612994 ## iteration 19 evolution: 12.67447 ## iteration 20 evolution: 9.597814 ## iteration 21 evolution: 5.658197 ## iteration 22 evolution: 2.98443 ## iteration 23 evolution: 2.079856 ## iteration 24 evolution: 2.490897 ## iteration 25 evolution: 0 # adding density curves from the 2 clusters lines(density(rnorm(1000, res$medias[1], res$desvpadrao[1]), bw = 40),lwd=2,col=3) lines(density(rnorm(1000, res$medias[2], res$desvpadrao[2]), bw = 40),lwd=2,col=4) ## column with 2 classes to classify data from each cluster attach(res$classe) classe2&lt;-ifelse(V1 == 1, 3 ,4) # create &#39;m&#39; classes detach() # ploting ECG inverted points according with the latent class it belongs to plot(1:length(fA1[,2]), fA1[,2]*(-1), col=classe2, pch=20, xlab=&quot;index&quot;, ylab=&quot;2nd lead ECG&quot;, main = &quot; ECG colored by class (m=2)&quot;) 2.7.4 EM algorithm for 3 latent classes par(mfrow=c(1,1)) # expectation-maximization algorithm with 3 latent classes and a maximum 50 iterations. res&lt;-emf(xx = fA1[,2]*(-1), itera = 50, m=3, method = &quot;crisp&quot;, main = &quot;second lead inverted&quot;, seed = 10) ## iteration 1 evolution: 175.0321 ## iteration 2 evolution: 84.11333 ## iteration 3 evolution: 41.73523 ## iteration 4 evolution: 43.49741 ## iteration 5 evolution: 28.14147 ## iteration 6 evolution: 11.77696 ## iteration 7 evolution: 9.002154 ## iteration 8 evolution: 6.878037 ## iteration 9 evolution: 3.751731 ## iteration 10 evolution: 4.932522 ## iteration 11 evolution: 0.6580674 ## iteration 12 evolution: 0 # adding density curves from the 3 clusters lines(density(rnorm(1000, res$medias[1], res$desvpadrao[1]), bw = 40),lwd=2,col=3) lines(density(rnorm(1000, res$medias[2], res$desvpadrao[2]), bw = 40),lwd=2,col=4) lines(density(rnorm(1000, res$medias[3], res$desvpadrao[3]), bw = 40),lwd=2,col=5) ## column with 3 classes to classify data from each cluster attach(res$classe) classe3&lt;-ifelse(V1 == 1, 3 , ifelse(V2 == 1, 4, 5)) # create &#39;m&#39; classes detach() # ploting ECG inverted points according with the latent class it belongs to plot(1:length(fA1[,2]), fA1[,2]*(-1), col=classe3, pch=20, xlab=&quot;index&quot;, ylab=&quot;2nd lead ECG&quot;, main = &quot; ECG colored by class (m=3)&quot;) 2.7.5 Generating 1000 data points at random with bootstrapped, with guassian distribution and EM with 3 clusters. ## length of data set generation n&lt;-1000 # original sample data set sample&lt;-fA1[,2]*(-1) # bootstrapped sample data set sample.obs&lt;-sample(sample, size=n, replace = TRUE) # gaussian generated data set sample.simple&lt;-rnorm(n,mean=mean(sample), sd=sd(sample)) # EM model generated data set #classes&lt;-apply(attrib, 1, which.max) # using attrib define previously, to calculate the number of observations in each class class.prop&lt;-prop.table(table(classe3)) # calculate percentage of each class m&lt;-3 set.seed(523) sample.classes&lt;-sample(1:m, size=n, replace=TRUE, prob=class.prop) sample.prop&lt;-prop.table(table(sample.classes)) sample.values&lt;-round(unlist(sapply(1:m, function(j){ rnorm(n*sample.prop[j], # generating number with the proportions of the two classes we identified previously mean=res$medias[j], # parameters defined previously sd=res$desvpadrao[j]) # parameters defined previously })),0) # Plotting results par(mfrow=c(2,2)) hist(sample, freq = F, main = &quot;Observed data&quot;, ylim = c(0,0.004)) lines(density(sample)) hist(sample.obs, freq = F, main = &quot;data points sampled from observed data&quot;, ylim = c(0,0.004)) lines(density(sample.obs)) hist(sample.simple, freq = F, main = &quot;data points generated from sample distribution&quot;, ylim = c(0,0.004)) lines(density(sample.simple)) hist(sample.values, freq = F, main = &quot;data points generated from EM (m=3)&quot;, ylim = c(0,0.004)) lines(density(sample.values)) 2.7.6 BONUS for a diferent solution: https://rpubs.com/franzbischoff/assignment2 "]
]
